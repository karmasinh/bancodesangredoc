2.9  MODELADO DE DATOS 
MODULO ADMINISTRACION

Tabla rol

CREATE TABLE rol (
  id_rol INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre VARCHAR(50) UNIQUE NOT NULL,
  descripcion VARCHAR(200),
  estado BOOLEAN DEFAULT TRUE
);

Tabla usuario

CREATE TABLE usuario (
  id_usr INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_pers INTEGER NOT NULL,
  login VARCHAR(40) UNIQUE NOT NULL,
  pass_hash VARCHAR(200) NOT NULL,
  estado BOOLEAN DEFAULT TRUE,
  CONSTRAINT fk_usuario_personal FOREIGN KEY (id_pers)
    REFERENCES personal(id_pers) ON UPDATE CASCADE ON DELETE RESTRICT
);

Tabla usuario_rol

CREATE TABLE usuario_rol (
  id_usr INTEGER NOT NULL,
  id_rol INTEGER NOT NULL,
  fecha_asig TIMESTAMP DEFAULT now(),
  PRIMARY KEY (id_usr, id_rol),
  CONSTRAINT fk_ur_usuario FOREIGN KEY (id_usr) REFERENCES usuario(id_usr),
  CONSTRAINT fk_ur_rol FOREIGN KEY (id_rol) REFERENCES rol(id_rol)
);

Tabla personal

CREATE TABLE personal (
  id_pers       INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nom           VARCHAR(60)  NOT NULL,
  ape_pat       VARCHAR(60)  NOT NULL,
  ape_mat       VARCHAR(60),
  ci            VARCHAR(20),
  profesion     VARCHAR(60),
  ocupacion     VARCHAR(60),
  fecha_naci    DATE,
  sexo          CHAR(1)      CHECK (sexo IN ('M','F')),
  email         VARCHAR(120),
  estado        BOOLEAN       DEFAULT TRUE
);


Tabla domicilio

CREATE TABLE domicilio (
  id_dom        INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_pers       INTEGER NOT NULL,
  calle_resid   VARCHAR(120),
  numero        VARCHAR(15),
  zona          VARCHAR(60),
  tipo_dom      VARCHAR(30), -- propio/alquiler/otro
  CONSTRAINT fk_dom_personal
    FOREIGN KEY (id_pers) REFERENCES personal(id_pers)
    ON UPDATE CASCADE ON DELETE CASCADE
);

Tabla fonos

CREATE TABLE fonos (
  id_fono       INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_pers       INTEGER NOT NULL,
  fono_princ    VARCHAR(30),
  celular       VARCHAR(30),
  fono_vecino   VARCHAR(30),
  fono_trab     VARCHAR(30),
  CONSTRAINT fk_fono_personal
    FOREIGN KEY (id_pers) REFERENCES personal(id_pers)
    ON UPDATE CASCADE ON DELETE CASCADE
);





Tabla horario_atencion

CREATE TABLE horario_atencion (
  id_horario    INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_pers       INTEGER NOT NULL,
  dia_semana    SMALLINT NOT NULL CHECK (dia_semana BETWEEN 1 AND 7), -- 1=Lunes
  hora_ini      TIME      NOT NULL,
  hora_fin      TIME      NOT NULL,
  observacion   VARCHAR(150),
  CONSTRAINT ck_horario_rango CHECK (hora_fin > hora_ini),
  CONSTRAINT fk_horario_personal
    FOREIGN KEY (id_pers) REFERENCES personal(id_pers)
    ON UPDATE CASCADE ON DELETE CASCADE
);

Tabla rol

CREATE TABLE rol (
  id_rol        INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre        VARCHAR(50)  NOT NULL UNIQUE,
  descripcion   VARCHAR(200),
  estado        BOOLEAN      DEFAULT TRUE
);

Tabla usuario

CREATE TABLE usuario (
  id_usr        INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_pers       INTEGER  NOT NULL,
  login         VARCHAR(40) NOT NULL UNIQUE,
  pass_hash     VARCHAR(200) NOT NULL, -- BCrypt/Argon2
  estado        BOOLEAN DEFAULT TRUE,
  CONSTRAINT fk_usuario_personal
    FOREIGN KEY (id_pers) REFERENCES personal(id_pers)
    ON UPDATE CASCADE ON DELETE RESTRICT
);





Tabla usuario_rol

CREATE TABLE usuario_rol (
  id_usr        INTEGER NOT NULL,
  id_rol        INTEGER NOT NULL,
  fecha_asig    TIMESTAMP DEFAULT now(),
  PRIMARY KEY (id_usr, id_rol),
  CONSTRAINT fk_ur_usuario FOREIGN KEY (id_usr) REFERENCES usuario(id_usr)
    ON UPDATE CASCADE ON DELETE CASCADE,
  CONSTRAINT fk_ur_rol     FOREIGN KEY (id_rol) REFERENCES rol(id_rol)
    ON UPDATE CASCADE ON DELETE RESTRICT
);

Tabla menu_item

CREATE TABLE menu_item (
  id_menu       INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre        VARCHAR(60)  NOT NULL,
  ruta          VARCHAR(120),        -- URL o código de pantalla
  orden         INTEGER      DEFAULT 0,
  estado        BOOLEAN      DEFAULT TRUE,
  id_padre      INTEGER,
  CONSTRAINT fk_menu_padre
    FOREIGN KEY (id_padre) REFERENCES menu_item(id_menu)
    ON UPDATE CASCADE ON DELETE SET NULL
);

Tabla rol_menu (menu que visualiza cada rol)

CREATE TABLE rol_menu (
  id_rol        INTEGER NOT NULL,
  id_menu       INTEGER NOT NULL,
  puede_ver     BOOLEAN DEFAULT TRUE,
  puede_crear   BOOLEAN DEFAULT FALSE,
  puede_editar  BOOLEAN DEFAULT FALSE,
  puede_borrar  BOOLEAN DEFAULT FALSE,
  PRIMARY KEY (id_rol, id_menu),
  CONSTRAINT fk_rm_rol  FOREIGN KEY (id_rol)  REFERENCES rol(id_rol)
    ON UPDATE CASCADE ON DELETE CASCADE,
  CONSTRAINT fk_rm_menu FOREIGN KEY (id_menu) REFERENCES menu_item(id_menu)
    ON UPDATE CASCADE ON DELETE CASCADE
);
Índice recomendado

CREATE INDEX ix_personal_apellidos ON personal(ape_pat, ape_mat, nom);
CREATE INDEX ix_horario_pers_dia   ON horario_atencion(id_pers, dia_semana);
CREATE INDEX ix_usuario_login      ON usuario(login);

MODULO CLINICO

Tabla persona

CREATE TABLE persona (
  id_per        INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nom           VARCHAR(60)  NOT NULL,
  ape_pat       VARCHAR(60)  NOT NULL,
  ape_mat       VARCHAR(60),
  ci            VARCHAR(20),
  sexo          CHAR(1)      CHECK (sexo IN ('M','F')),
  fecha_naci    DATE,
  email         VARCHAR(120),
  procedencia   VARCHAR(80)
); 

Tabla domicilio_per (domicilio del paciente / persona)

CREATE TABLE domicilio_per (
  id_dom        INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_per        INTEGER NOT NULL,
  calle_resid   VARCHAR(120),
  numero        VARCHAR(15),
  zona          VARCHAR(60),
  tipo_dom      VARCHAR(30), -- propio/alquiler/otro
  CONSTRAINT fk_domper_persona
    FOREIGN KEY (id_per) REFERENCES persona(id_per)
      ON UPDATE CASCADE ON DELETE CASCADE
);

Tabla fono_per (teléfonos del paciente / persona)
	
CREATE TABLE fono_per (
  id_fono       INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_per        INTEGER NOT NULL,
  fono_princ    VARCHAR(30),
  celular       VARCHAR(30),
  fono_vecino   VARCHAR(30),
  fono_trab     VARCHAR(30),
  CONSTRAINT fk_fonoper_persona
    FOREIGN KEY (id_per) REFERENCES persona(id_per)
      ON UPDATE CASCADE ON DELETE CASCADE
);

Tabla donante

CREATE TABLE donante (
  id_don        INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_per        INTEGER NOT NULL UNIQUE,
  cod_don       VARCHAR(15) UNIQUE,
  grupo_sang    VARCHAR(3),         -- O+, A-, etc. (si usas catálogo, referencia allí)
  rh            VARCHAR(2),         -- opcional si separas grupo y Rh
  tipo_donante  VARCHAR(30),        -- Voluntario/Reposición
  estado        VARCHAR(15) DEFAULT 'ACTIVO',
  CONSTRAINT fk_donante_persona
    FOREIGN KEY (id_per) REFERENCES persona(id_per)
      ON UPDATE CASCADE ON DELETE RESTRICT
);

Tabla admisión (toma de datos / inicio de atencion)

CREATE TABLE admision (
  id_adm        INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_don        INTEGER NOT NULL,
  fecha_hora    TIMESTAMP NOT NULL DEFAULT now(),
  usuario_reg   VARCHAR(60),        -- opcional: quién registró
  observacion   VARCHAR(250),
  CONSTRAINT fk_adm_don
    FOREIGN KEY (id_don) REFERENCES donante(id_don)
      ON UPDATE CASCADE ON DELETE RESTRICT
);

Tabla tamizaje_medico (cuestionario y criterios)

CREATE TABLE tamizaje_medico (
  id_tam        INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_adm        INTEGER NOT NULL UNIQUE,      -- 1 tamizaje por admisión
  cuestionario  JSONB,                        -- respuestas del cuestionario
  criterios_ok  BOOLEAN,
  apto_pre      BOOLEAN,
  observacion   VARCHAR(250),
  CONSTRAINT fk_tam_adm
    FOREIGN KEY (id_adm) REFERENCES admision(id_adm)
      ON UPDATE CASCADE ON DELETE CASCADE
);

Tabla examen_fisico (signos y aptitudes)

CREATE TABLE examen_fisico (
  id_fis        INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_adm        INTEGER NOT NULL UNIQUE,      -- 1 examen por admisión
  tension       VARCHAR(15),                  -- ej. 120/80
  pulso         SMALLINT,
  temperatura   NUMERIC(4,1),
  talla_cm      NUMERIC(5,2),
  peso_kg       NUMERIC(5,2),
  apto          BOOLEAN,
  observacion   VARCHAR(250),
  CONSTRAINT fk_fis_adm
    FOREIGN KEY (id_adm) REFERENCES admision(id_adm)
      ON UPDATE CASCADE ON DELETE CASCADE
);

Tabla extracción 

CREATE TABLE extraccion (
  id_ext        INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_adm        INTEGER NOT NULL,
  fecha_hora    TIMESTAMP NOT NULL DEFAULT now(),
  bolsa_cod     VARCHAR(30) UNIQUE,           -- etiqueta única
  volumen_ml    SMALLINT,
  estado        VARCHAR(15) NOT NULL DEFAULT 'VALIDA',  -- VALIDA/ANULADA
  CONSTRAINT fk_ext_adm
    FOREIGN KEY (id_adm) REFERENCES admision(id_adm)
      ON UPDATE CASCADE ON DELETE RESTRICT
);




Índices recomendados

-- Búsqueda rápida por documento o nombre
CREATE INDEX ix_persona_ci         ON persona(ci);
CREATE INDEX ix_persona_apellidos  ON persona(ape_pat, ape_mat, nom);

-- Relaciones frecuentes
CREATE INDEX ix_domper_idper       ON domicilio_per(id_per);
CREATE INDEX ix_fonoper_idper      ON fono_per(id_per);
CREATE INDEX ix_donante_idper      ON donante(id_per);

-- Trazabilidad de atención
CREATE INDEX ix_adm_iddon_fh       ON admision(id_don, fecha_hora DESC);
CREATE INDEX ix_tam_idadm          ON tamizaje_medico(id_adm);
CREATE INDEX ix_fis_idadm          ON examen_fisico(id_adm);
CREATE INDEX ix_ext_idadm_fh       ON extraccion(id_adm, fecha_hora DESC);

-- Búsqueda por código de bolsa
CREATE UNIQUE INDEX ux_ext_bolsa   ON extraccion(bolsa_cod);

MODULO 3 LABORATORIO

Tabla tipo_prueba

CREATE TABLE tipo_prueba (
  id_tipoprueba INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre        VARCHAR(60) UNIQUE NOT NULL,    -- Inmunohematología, Inmunoserología, etc.
  descripcion   VARCHAR(200),
  activo        BOOLEAN DEFAULT TRUE
);


Tabla prueba_lab

CREATE TABLE prueba_lab (
  id_prueba     INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_ext        INTEGER NOT NULL,               -- referencia a extracción
  id_tipoprueba INTEGER NOT NULL,
  fecha_hora    TIMESTAMP NOT NULL DEFAULT now(),
  realizado_por INTEGER,                        -- id_personal que ejecuta
  estado        VARCHAR(15) DEFAULT 'PENDIENTE',-- PENDIENTE/OK/INVALIDA
  observacion   VARCHAR(200),
  CONSTRAINT fk_prueba_ext FOREIGN KEY (id_ext)
    REFERENCES extraccion(id_ext)
      ON UPDATE CASCADE ON DELETE CASCADE,
  CONSTRAINT fk_prueba_tipo FOREIGN KEY (id_tipoprueba)
    REFERENCES tipo_prueba(id_tipoprueba)
      ON UPDATE CASCADE ON DELETE RESTRICT
);

Tabla resultado_lab

CREATE TABLE resultado_lab (
  id_result     INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_prueba     INTEGER NOT NULL UNIQUE,
  resultado     VARCHAR(120),                   -- Ej: "Negativo", "O+", etc.
  detalle       JSONB,                          -- valores adicionales
  validado      BOOLEAN DEFAULT FALSE,
  validado_por  INTEGER,                        -- id_personal que valida
  validado_en   TIMESTAMP,
  CONSTRAINT fk_result_prueba FOREIGN KEY (id_prueba)
    REFERENCES prueba_lab(id_prueba)
      ON UPDATE CASCADE ON DELETE CASCADE
);

Tabla control_calidad_lab

CREATE TABLE control_calidad_lab (
  id_cc         INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_prueba     INTEGER NOT NULL,
  parametro     VARCHAR(60) NOT NULL,           -- PH, volumen, etc.
  valor         VARCHAR(60),
  conforme      BOOLEAN,
  fecha_control TIMESTAMP DEFAULT now(),
  CONSTRAINT fk_cc_prueba FOREIGN KEY (id_prueba)
    REFERENCES prueba_lab(id_prueba)
      ON UPDATE CASCADE ON DELETE CASCADE
);






Tabla validación_lab

CREATE TABLE validacion_lab (
  id_validacion INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_result     INTEGER NOT NULL,
  id_personal   INTEGER,                        -- quien valida
  fecha_val     TIMESTAMP DEFAULT now(),
  observacion   VARCHAR(250),
  estado        VARCHAR(20) DEFAULT 'VALIDADO', -- VALIDADO / INVALIDADO
  CONSTRAINT fk_valid_result FOREIGN KEY (id_result)
    REFERENCES resultado_lab(id_result)
      ON UPDATE CASCADE ON DELETE CASCADE,
  CONSTRAINT fk_valid_personal FOREIGN KEY (id_personal)
    REFERENCES personal(id_pers)
      ON UPDATE CASCADE ON DELETE SET NULL
);

Índices recomendados 

CREATE INDEX ix_prueba_ext         ON prueba_lab(id_ext);
CREATE INDEX ix_prueba_tipo        ON prueba_lab(id_tipoprueba);
CREATE INDEX ix_result_validado    ON resultado_lab(validado);
CREATE INDEX ix_validacion_result  ON validacion_lab(id_result);
CREATE INDEX ix_cc_prueba          ON control_calidad_lab(id_prueba);

MODULO 4 PRODUCCION / CONTROL DE CALIDAD / DISTRIBUCCION

Tabla hemocomponente

CREATE TABLE hemocomponente (
  id_hemo       INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_ext        INTEGER NOT NULL,             -- referencia a la extracción
  tipo          VARCHAR(40) NOT NULL,         -- GR, PFC, PLAQ, CRIO, etc.
  volumen_ml    SMALLINT,
  fecha_prep    DATE DEFAULT CURRENT_DATE,
  fecha_venc    DATE,
  estado        VARCHAR(20) DEFAULT 'DISPONIBLE', -- DISPONIBLE / BAJA / RESERVADO
 



 observacion   VARCHAR(200),
  CONSTRAINT fk_hemo_ext FOREIGN KEY (id_ext)
    REFERENCES extraccion(id_ext)
      ON UPDATE CASCADE ON DELETE RESTRICT
);

Tabla control_calidad_hemo

CREATE TABLE control_calidad_hemo (
  id_cc_hemo    INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_hemo       INTEGER NOT NULL,
  parametro     VARCHAR(60) NOT NULL,          -- pH, volumen, color, etc.
  valor         VARCHAR(60),
  conforme      BOOLEAN,
  fecha_control TIMESTAMP DEFAULT now(),
  observacion   VARCHAR(200),
  CONSTRAINT fk_cc_hemo FOREIGN KEY (id_hemo)
    REFERENCES hemocomponente(id_hemo)
      ON UPDATE CASCADE ON DELETE CASCADE
);

Tabla destino

CREATE TABLE destino (
  id_destino    INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre        VARCHAR(120) NOT NULL,         -- Hospital o clínica
  direccion     VARCHAR(200),
  telefono      VARCHAR(30),
  responsable   VARCHAR(120),
  activo        BOOLEAN DEFAULT TRUE
);

Tabla pedido

CREATE TABLE pedido (
  id_pedido     INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_destino    INTEGER NOT NULL,
  fecha_solic   TIMESTAMP DEFAULT now(),
  estado        VARCHAR(20) DEFAULT 'PENDIENTE',  -- PENDIENTE / DESPACHADO / ENTREGADO
  observacion   VARCHAR(200),
  CONSTRAINT fk_pedido_destino FOREIGN KEY (id_destino)
    REFERENCES destino(id_destino)
      ON UPDATE CASCADE ON DELETE RESTRICT
);

Tabla detalle_pedido

CREATE TABLE detalle_pedido (
  id_pedido     INTEGER NOT NULL,
  id_hemo       INTEGER NOT NULL,
  cantidad      INTEGER DEFAULT 1,
  PRIMARY KEY (id_pedido, id_hemo),
  CONSTRAINT fk_det_pedido FOREIGN KEY (id_pedido)
    REFERENCES pedido(id_pedido)
      ON UPDATE CASCADE ON DELETE CASCADE,
  CONSTRAINT fk_det_hemo FOREIGN KEY (id_hemo)
    REFERENCES hemocomponente(id_hemo)
      ON UPDATE CASCADE ON DELETE RESTRICT
);

Tabla entrega

CREATE TABLE entrega (
  id_entrega    INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_pedido     INTEGER NOT NULL,
  recibido_por  VARCHAR(120),
  fecha_entrega TIMESTAMP DEFAULT now(),
  observacion   VARCHAR(200),
  estado        VARCHAR(20) DEFAULT 'ENTREGADO',  -- ENTREGADO / PENDIENTE
  CONSTRAINT fk_entrega_pedido FOREIGN KEY (id_pedido)
    REFERENCES pedido(id_pedido)
      ON UPDATE CASCADE ON DELETE CASCADE
);

Tabla distribución_log

CREATE TABLE distribucion_log (
  id_log        INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_entrega    INTEGER NOT NULL,
  id_hemo       INTEGER NOT NULL,
  estado_anterior VARCHAR(20),
  estado_nuevo    VARCHAR(20),
  fecha_evento    TIMESTAMP DEFAULT now(),
  usuario_reg     VARCHAR(60),
  CONSTRAINT fk_log_entrega FOREIGN KEY (id_entrega)
    REFERENCES entrega(id_entrega)
      ON UPDATE CASCADE ON DELETE CASCADE,
  CONSTRAINT fk_log_hemo FOREIGN KEY (id_hemo)
    REFERENCES hemocomponente(id_hemo)
      ON UPDATE CASCADE ON DELETE RESTRICT
);




Índices recomendados

CREATE INDEX ix_hemo_ext           ON hemocomponente(id_ext);
CREATE INDEX ix_hemo_estado        ON hemocomponente(estado);
CREATE INDEX ix_pedido_destino     ON pedido(id_destino);
CREATE INDEX ix_det_pedido_hemo    ON detalle_pedido(id_hemo);
CREATE INDEX ix_entrega_pedido     ON entrega(id_pedido);
CREATE INDEX ix_log_hemo_estado    ON distribucion_log(id_hemo, estado_nuevo);


3.5 ESPECIFICACIÓN DE MÉTODOS

Las especificaciones de métodos describen el comportamiento de un procedimiento en términos de sus precondiciones y postcondiciones, también referirse solamente a los campos de especificación, a los argumentos del método y a las variables globales, pero nunca a procedimientos concretos.

Clase de conexión

		
		c = openConnection();
		stmt = c.createStatement();
		// reads the file with the SQL statements
		String line;
		while ((line = reader.readLine()) != null) {
				stmt.execute(line);
			}
			stmt.close();
			c.close();
		} catch (IOException e) {
			e.printStackTrace();
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			try {
				stmt.close();
				c.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		
	public static Connection openConnection() throws SQLException {
	Connection c = DriverManager.getConnection("jdbc:postgresql:BasedeDatos", "postgres", "");
		return c;
	}


Listar,  adicionar,  modificar,  eliminar  personal 

Listar
public Collection listarPersonal() {
String  sql ="";
sql ="select p1.cod_per,p.nom,p.apepa,p.apema,p1.profesion from personal sql +="p1,persona p where where cod_per=t.cod_per and 
sql +="p1.id_per=p.id_per;";
NivelesRevicionLab ap = new NivelesRevicionLab();
ap.setCod_per(rs.getString("cod_per"));
ap.setNom(rs.getString("nom"));
ap.setApepa(rs.getString("apepa"));
ap.setApema(rs.getString("apema"));
ap.setProfesion(rs.getString("profesion"));
return ap;
} 

Este método visualiza una lista de datos de todo el personal que tiene insertado en la tablas personal y persona.

Adicionar

public void adicionarPersonal()  
{ 
String  sql ="";                
sql = "insert into  personal(id_per,cod_per,cargo,grado) 
sql + = values("+id_per+", '"+cod_per+"','"+cargo+"','"+grado+"');";
}	        

Este método adiciona los datos que son recuperados de los objetos que se encuentran en la pantalla Nuevo personal.


Modificar 
public void modificarPersonal()  
{
String sql="";
sql = "update personal set contraseña = '"+cod_per+"', 
sql+ = profesion='"+profesion+"',grado='"+grado+"' ,
sql+ = usuario='"+usuario+"' where id_per = "+id_per+" ;";
}
Este método modifica los datos que son recuperados de los objetos que se encuentran en la pantalla Modificar personal.


Eliminar 

public void eliminarPersonal()
{
String sql1="";
Sql1 = "delete from domicilio  where id_per = "+id_per+" ;";
String sql2="";
sql2 = "delete from fonos  where id_per = "+id_per+" ;";
String sql3="";
Sql3 = "delete from persona  where id_per = "+id_per+" ;";
String sql4="";
Sql4 = "delete from personal  where id_per = "+id_per+" ;";
}
Este método elimina los datos que son recuperados de los objetos que se encuentran en la pantalla Eliminar Personal.
Adicionar,  modificar, listar Nuevo (persona, domicilio, fonos, donante)

Adicionar 

String sql1 = "insert into  persona(id_per, nom, apepa,apema,ci, prof, sql1+ = "ocu, fechanaci,sexo,casilla,lugar_tra,pasaporte,fax,procedencia,
sql1+ = "email,edad) values("+id_per+",'"+nom+"','"+apepa+"','"+apema+"', sql1+ = " "+ci+",'"+prof+"','"+ocu+"','"+fecha_naci+"', "+sexo+"',
sql1+ = " '"+casilla+"','"+lugar_tra+"','"+pasaporte+"',
sql1+ = '"+fax+"','"+procedencia+"','"+email+"',"+edad+");";
				  
sql2  = "insert into  donante(id_per,cod_do) values("+id_per+", 
sql2+ = "'"+cod_do+"');";
	        	    
sql3  = "insert into  fonos(id_per, fono_pro, cel, fono_vec, fono_tra) sql3+ = "values("+id_per+", "+fono_pro+", "+cel+", "+fono_vec+", 
sql3+ = ""+fono_tra+");";
	        	
Sql4  = "insert into  domicilio(id_per, 
Sql4+ = "calle_residencia,num,zona,tipo_dom) values("+id_per+", 
Sql4+ = "'"+calle_residencia+"','"+num+"', '"+zona+"', '"+tipo_dom+"');";
e.printStackTrace();	        	
		

Este método adiciona los datos del donante que son recuperados de los objetos que se encuentran en la pantalla Nuevo. 

Modificar

public void modificar_Datos_Donante()  
{
String sql1="";
	       
Sql1 = "update persona set prof = '"+prof+"', ocu='"+ocu+"', 
Sql1 += lugar_tra='"+lugar_tra+"',email='"+email+"' 
Sql1 += where id_per = "+id_per+" ;";
String sql2="";
Sql2 = "update fonos set fono_pro = '"+fono_pro+"', cel='"+cel+"', 
Sql2+ = fono_vec='"+fono_vec+"' ,fono_tra='"+fono_tra+"'  
Sql2+ = where id_per = "+id_per+" ;";
String sql3="";
Sql3 = "update domicilio set calle_residencia = '"+calle_residencia+"', Sql3+ = num='"+num+"', zona ='"+zona+"'  
Sql3+ = where (id_per = "+id_per+")and (tipo_dom='"+tipo_dom+"') ;";	 
String sql4="";
Sql4 = "update domicilio set calle_residencia = '"+calle_residenciat+"', Sql4 += num='"+numt+"', zona ='"+zonat+"'  
Sql4 += where (id_per = "+id_per+")and(tipo_dom='"+tipo_domt+"') ;";	  
}

Este método modifica los datos del donante que son recuperados de los objetos que se encuentran en la pantalla Agregar Donante. 

Listar

public Collection listarDonante() {
Collection lista = new Vector();
String sql=""
sql="select p.lugar_tra,p.email,f.fono_pro,f.cel,f.fono_vec,f.fono_tra 
sql+="dd.calle_residencia,dd.num,dd.zona,dd.tipo_dom 
sql+="d.cod_do,p.id_per,p.nom,p.apepa,p.apema,p.ci,p.prof,d.gs_rh,p.ocu  
sql+="from persona p, donante d,fonos f,domicilio dd
sql+="where(p.id_per=d.id_per)and(p.id_per=f.id_per)and(p.ci ='"+ci+"');
NivelesRevicionLab ap = new NivelesRevicionLab();
ap.setLugar_tra(rs.getString("lugar_tra"));
ap.setEmail(rs.getString("email"));
ap.setFono_pro(rs.getInt("fono_pro"));
ap.setCel(rs.getInt("cel"));
ap.setFono_vec(rs.getInt("fono_vec"));
ap.setFono_tra(rs.getInt("fono_tra"));
ap.setCalle_residencia(rs.getString("calle_residencia"));
ap.setNum(rs.getString("num"));
ap.setZona(rs.getString("zona"));
ap.setTipo_dom(rs.getString("tipo_dom"));
ap.setCod_do(rs.getString("cod_do"));
ap.setId_per(rs.getInt("id_per"));
ap.setNom(rs.getString("nom"));
ap.setApepa(rs.getString("apepa"));
ap.setApema(rs.getString("apema"));
ap.setCi(rs.getInt("ci"));
ap.setProf(rs.getString("prof"));
ap.setGs_rh(rs.getString("gs_rh"));
ap.setOcu(rs.getString("ocu"));
return ap;
}

Este método visualiza una lista de datos de todo del donante  que tiene insertado en la tablas  persona, donante, domicilio, fonos.
	        







Buscar Donante



Public BuscarDonante(){
sql+="select a.id_aten,a.fecha_a,p.edad,rp.resultado ";
sql+="from atencion a,persona p,donante d,prueba pp,
sql+="resultado_prueba rp ";
sql+="where (p.id_per=d.id_per) and (d.cod_do=a.cod_do) and 
sql+=" (a.id_aten=rp.id_aten)";
sql+="and(rp.id_prueba=pp.id_prueba)and(rp.instancia='inmunoserelogia')";
sql+="and (p.ci='"+ci+"') ;";
NivelesRevicionLab ap = new NivelesRevicionLab();
ap.setId_aten(rs.getInt("id_aten"));
ap.setFecha_a(rs.getString("fecha_a"));
ap.setEdad(rs.getInt("edad"));
ap.setResultado (rs.getString("resultado"));
return ap;
}

Este método realiza la búsqueda de acuerdo a los datos que son recuperados de los objetos que se encuentran en la pantalla Búsqueda de donante.

Adicionar Examen Físico 
 

Adicionar  

Public void insertarExamenF(){
sql  = "insert into atencion(fecha_a,hora_a,id_aten,tipo_do,veces,
sql+ = "cod_do,sistolica,diastolica,pulso,peso,talla,temperatura,cod_per,
sql+ = "id_horario) values('"+fecha_a+"','"+hora_a+"',"+id_aten+", 
sql+ = "'"+tipo_do+"', '"+veces+"', '"+cod_do+"' '"+sistolica+"',
sql+ = '"+diastolica+"','"+pulso+"','"+peso+"',"+talla+","+temperatura+",
sql+ = "'"+cod_per+"',"+id_horario+");";
e.printStackTrace();}
Este método adiciona los datos del examen físico que fueron tomados al donante después de haberse registrado sus datos personales.

Adicionar, listar, modificar  Evaluación 

 
Adicionar 

Public void insertarEva() {
sql  = "insert into evaluación (obs,ayunas,numeral,ingestion,rechazo, "
sql+ = "atendido,resultado,id_horario,cod_do,cod_per,fecha_a,id_eva)
sql+ = "values('"+obs+"','"+ayunas+"','"+numeral+"','"+ingestion+"',
sql+ = "'"+rechazo+"','"+atendido+"','"+r+"',"+id_horario+",
sql+ = "'"+cod_do+"','"+cod_per+"','"+fecha_a+"',"+id_aten+");";
}		        	 
Este método adiciona los datos de la evaluación que son recuperados de los objetos que se encuentran en la pantalla registrar Tamizaje Medico que realiza el doctor al donante.
Modificar 

public void modificarRevicion()  
{
String sql="";
sql = "update evaluacion set ayunas='"+ayunas+"',
sql+ = ingestion='"+ingestion+"', obs='"+obs+"',
sql+ = resultado='"+resultado+"',rechazo='"+rechazo+"',
sql+ = numeral='"+numeral+"' where (id_aten="+id_aten+");";
}

Este método modifica los datos de la evaluación que son recuperados de los objetos que se encuentran en la pantalla modificar Tamizaje Medico que realiza el doctor al donante.


Listar

public Collection mostrarEvaluacion(int id_aten) {
String sql="";
sql="select obs,ayunas,numeral,ingestion,rechazo,resultado from sql+="evaluacion  where(id_aten = "+id_aten+");";
NivelesRevicionLab ap = new NivelesRevicionLab();
ap.setObs(rs.getString("obs"));
ap.setAyunas(rs.getString("ayunas"));
ap.setNumeral(rs.getString("numeral"));
ap.setIngestion(rs.getString("ingestion"));
ap.setRechazo(rs.getString("rechazo"));
ap.setResultado(rs.getString("resultado"));
return ap;
}

Este método visualiza una lista de datos  de la evaluación que tiene insertado en las tablas evaluación. 

Adicionar, modificar resultado_prueba


Adicionar

Public void insertarPredonacion(){
sql  = "insert into resultado_prueba(resultado,id_prueba,cod_do,
sql += id_aten,instancia, hora_prueba,cod_per,id_horario,
sql + = "fecha_a) values('"+valores+"', "+id_prueba+",
sql + = "'"+cod_do+"',"+id_aten+",'"+instancia+"','"+hora_prueba+"',
sql + = "'"+cod_per+"',"+id_horario+",'"+fecha_prueba+"');";
}	        
Este método adiciona los datos de la pre donación que son recuperados de los objetos que se encuentran en la pantalla registrar Pre donación.


Modificar
Public void modificarPredo(){
sql  = "update resultado_prueba  set resultado ='"+valores+"'
sql+ = ",fecha_a='"+fecha_prueba+"',hora_prueba='"+hora_prueba+"',
sql+ = " cod_per='"+cod_per+"',id_horario="+id_horario+"  where
sql+ = " (id_prueba = "+id_prueba+")and(id_aten="+id_aten+")
sql+ = " and(cod_do='"+cod_do+"') ;";
}

Este método modifica  los datos de la pre donación que son recuperados de los objetos que se encuentran en la pantalla modificar Pre donación que realiza la bioquímica al donante.

Listar

public Collection mostrarResultado_prueba() {
String sql = "select r.resultado,r.id_prueba,p.tipo_componente,
sql += r.id_aten,r.cod_do  from resultado_prueba r,prueba p,atencion a sql += where (r.cod_do='"+cod_do+"')and(p.tipo='pre- donacion')and
sql += (a.cod_do=r.cod_do)and(r.id_prueba=p.id_prueba)
sql += and(a.id_aten=(select max(t.id_aten) from resultado_prueba t 
sql += where(t.cod_do='"+cod_do+"') and
sql += (t.instancia='pre-donacion') ))and(a.id_aten=r.id_aten) 
sql += ORDER BY id_prueba ";
NivelesRevicionLab ap = new NivelesRevicionLab();
ap.setResultado(rs.getString("resultado"));
ap.setId_prueba(rs.getInt("id_prueba"));
ap.setTipo_componente(rs.getString("tipo_componente"));
ap.setId_aten(rs.getInt("id_aten"));
ap.setCod_do(rs.getString("cod_do"));
return ap;}

Este método visualiza una lista de datos de la pre donación que tiene insertado en la tabla resultado_prueba. 

Adicionar, modificar Extracción 

 

Adicionar

Public void insertarExtra(){
String sqlpw="";
sqlpw   = "insert into extraccion(hora,bolsa,tubuladora,cant_extra,
sqlpw + = "fraccionado,cod_do,cod_per,id_horario,fecha_a,id_ext) values sqlpw + = "('"+hora+"','"+bolsa+"','"+tubuladora+"','"+cant_extra+"',
sqlpw + = '"+fraccionado+"','"+cod_do+"','"+cod_per+"',"+id_horario+",
sqlpw + = '"+fecha_extra+"',"+id_aten+");";
}

Este método adiciona  los datos de la extracción que son recuperados de los objetos que se encuentran en la pantalla registrar Extracción  que realiza la bioquímica al donante.

Modificar

Public void modifExtra(){
sqlpw = "update extraccion set fecha_a='"+fecha_extra+"',hora='"+hora+"', sqlpw + = " bolsa='"+bolsa+"',tubuladora='"+tubuladora+"', 
sqlpw + = " cant_extra='"+cant_extra+"',cod_per='"+cod_per+"',   
sqlpw + = " id_horario="+id_horario+" where id_ext="+id_ext+";";
}

Este método modifica  los datos de la extracción que son recuperados de los objetos que se encuentran en la pantalla modificar extracción  que realiza la bioquímica al donante.




Listar

public Collection mostrarListaExtra() {
String  sqla ="";
sqla +="select id_ext,bolsa,tubuladora,cant_extra  from extraccion  
sqla +="where  id_ext=(select max(id_ext) from extraccion)and 
sqla +=" (cod_do='"+cod_do+"');";	        				
NivelesRevicionLab ap = new NivelesRevicionLab();

ap.setBolsa(rs.getString("bolsa"));
ap.setTubuladora(rs.getString("tubuladora"));
ap.setCant_extra(rs.getString("cant_extra"));
return ap;
}
       
Este método visualiza una lista de datos de la extracción que tiene insertado en la tabla extracción. 










Listar, adicionar, modificar Produce 

 

Listar

Public collection listarPro(){
sqla  ="select distinct(a.id_aten),a.cod_do,e.fecha_a,e.id_ext,
sqla +="rp.resultado,p.id_prueba,e.bolsa from  atencion a,extraccion 
sqla +="e,resultado_prueba rp,prueba p where(a.id_aten=e.id_ext) 
sqla +="and not(e.bolsa='Simples')
sqla +="and((a.id_aten=rp.id_aten)and(rp.instancia='inmunohematologia'))
sqla +="and((p.id_prueba=rp.id_prueba)and(p.nombre_tp='Placa Gs-Rh')) ;";
NivelesRevicionLab ap = new NivelesRevicionLab();
ap.setCod_do(rs.getString("cod_do"));
ap.setId_aten(rs.getInt("id_aten"));
ap.setFecha_a(rs.getString("fecha_a"));
ap.setId_ext(rs.getInt("id_ext"));
ap.setRp.resultado (rs.getString("rp.resultado"));
ap.setId_prueba(rs.getInt("id_prueba"));
return ap;
}

Este método visualiza una lista de datos que se encuentran para efectuar la producción que realiza la bioquímica.

Adicionar

public void insertrProduccion(){
sqlw   = "insert into produce(id_prod,id_hemo,cod_do,cantidad,fecha_expi,
sqlw + = "id_ext,pruebas_salida,control_calidad,gs_rh,fecha_a,estado,
sqlw + = "cod_per,id_horario) values ("+id_prod+","+n0+",'"+cod_do+"',
sqlw + = '"+cantidad+"','"+fecha_expi+"',"+id_ext+",'"+pruebas+"',
sqlw + = '"+control+"','"+resultado+"','"+fecha_produccion+"',
sqlw + = '"+cod_per+"',"+id_horario+")  ;";
}  

Este método adiciona los datos del registro de producción que son recuperados de los objetos que se encuentran en la pantalla registrar producción que realiza la bioquímica 




Modificar

public void modificarProduccion(){
sqlw   = "UPDATE produce SET fecha_expi = '"+fecha_expi+"',
sqlw + = "fecha_a='"+fecha_produccion+"', id_hemo="+id_hemo+",
sqlw + = "cod_per='"+cod_per+"',id_horario="+id_horario+"   
sqlw + = " WHERE id_prod = "+id_prod+"   ;";
 }  

Este método modifica  los datos del registro de producción  que son recuperados de los objetos que se encuentran en la pantalla modificar producción.

Registrar Salida

 

Listar

public Collection Listar(){
sqla   ="select p.fecha_expi,h.nombre,p.id_prod,p.gs_rh,p.cod_do,
sqla + ="e.tubuladora from hemocomponente h,produce p,extraccion e 
sqla + ="where (p.id_hemo=h.id_hemo)and(p.id_ext=e.id_ext)
sqla + ="and(e.fraccionado='A')and(p.estado=1)and(pruebas_salida='N')
sqla + ="and(p.gs_rh='"+gs_rh+"')and(p.id_hemo="+id_hemo+") 
sqla + ="order by(fecha_expi); ";
NivelesRevicionLab ap = new NivelesRevicionLab();
ap.setFecha_expi (rs.getString("fecha_expi "));
ap.setId_prod (rs.getInt("id_prod "));
ap.setNombre (rs.getString("nombre "));
ap.setGs_rh(rs.getString("gs_rh "));
ap.setId_prueba(rs.getInt("id_prueba"));
ap.setCod_do(rs.getString("cod_do"));
ap.setTubuladora (rs.getString("tubuladora"));
return ap;
}

Este método visualiza una lista de datos que se encuentran para efectuar la salida que realiza la bioquímica.










Listar, insertar Control de Calidad

 

Listar

public Collection ListarHemocomponentes(){
sqla   ="select h.nombre,h.id_hemo,p.gs_rh,p.fecha_expi,e.id_ext 
sqla + ="from hemocomponente h,produce p,extraccion e where 
sqla + ="(p.id_hemo = h.id_hemo)and(p.id_ext=e.id_ext);";
NivelesRevicionLab ap = new NivelesRevicionLab();
ap.setFecha_expi (rs.getString("fecha_expi "));
ap.setId_hemo(rs.getInt("id_hemo "));
ap.setNombre (rs.getString("nombre "));
ap.setGs_rh(rs.getString("gs_rh "));
ap.setId_ext(rs.getInt("id_ext"));
return ap;
}

Este método visualiza una lista de datos que se encuentran para efectuar la control de calidad que realiza la bioquímica.

Insertar

public void insertarControlCalidad() {
Sql   = "insert into resultado_prueba(resultado,id_prueba,cod_do,id_aten,
sql + = "instancia,hora_prueba,cod_per,id_horario,fecha_a) 
sql + = "values('"+valores+"', "+id_prueba+",'"+cod_do+"', 
sql + = "+id_aten+",'"+instancia+"','"+hora_prueba+"','"+cod_per+"',
sql + = "+id_horario+",'"+fecha_prueba+"');";
}

Este método adiciona los datos del registro de control de calidad que son recuperados de los objetos que se encuentran en la pantalla registrar control de calidad que realiza la bioquímica.

Adicionar, modificar, eliminar, listar Roles

 
Listar

public Collection ListarRoles(){
Collection lista=new Vector();
String consulta="select id_rol,nombre from roles;";
NivelesRevicionLab ap = new NivelesRevicionLab();
ap.setId_rol(rs.getInt("id_rol"));
ap.setNombre (rs.getString("nombre "));
return ap;
}
Este método visualiza una lista de roles que se encuentra en la tabla de roles.

Modificar

public void modificarRol()  
{
String sqlpw="";    
sqlpw = "update roles set nombre = '"+nombre+"'  where id_rol = "+id+" ;";}
Este método modifica  los datos del registro roles  que son recuperados de los objetos que se encuentran en la pantalla modificar roles.

Eliminar 


public void eliminarRol()  
{
String sqlpw="";
sqlpw = "delete from roles  where id_rol ="+id_rol +"  ;";
}

Este método elimina los datos del registro roles  que son recuperados de los objetos que se encuentran en la pantalla eliminar roles.
Adicionar

public void insertaRol()  
{                    
String sqlpw="";
sqlpw  = "insert into roles(id_rol,nombre)
sqlpw += values("+id_rol+",'"+nombre+"');";
}

Este método adiciona los datos del registro roles que son recuperados de los objetos que se encuentran en la pantalla registrar Rol que realiza la bioquímica.

Adicionar, modificar, eliminar, listar Hemocomponentes


 

Adicionar 

public void adicionarHemocomponente()  
{       
String sqlpw="";
sqlpw = "insert into hemocomponente(id_hemo,nombre,descripcion,estado) values("+id_hemo+",'"+nombre+"','"+descripcion+"','+estado+');";
}

Este método adiciona los datos del registro hemocomponente que son recuperados de los objetos que se encuentran en la pantalla registrar hemocomponente que realiza la bioquímica.


Modificar 

public void modificarHemocomponente(){
String sqlpw="";	    
sqlpw = "update hemocomponente set descripcion = '"+descripcion+"', 
sqlpw += nombre='"+nombre+"'  where id_hemo = "+id_hemo+" ;";
}

Este método modifica  los datos del registro hemocomponente  que son recuperados de los objetos que se encuentran en la pantalla modificar hemocomponente.

Eliminar

public void eliminarHemocomponente()
{
String sqlp1="";
sqlp1 = "delete from hemocomponente where id_hemo = "+id_hemo+" ;";
}

Este método elimina  los datos del registro hemocomponente  que son recuperados de los objetos que se encuentran en la pantalla Eliminar hemocomponente.


Listar 

public Collection mostrarLista() {
String  sqla ="select id_hemo,nombre,descripcion  from hemocomponente; 
NivelesRevicionLab ap = new NivelesRevicionLab();
ap.setId_hemo(rs.getInt("id_hemo"));		
ap.setNombre(rs.getString("nombre"));
ap.setDescripcion(rs.getString("descripcion"));				
return ap;
}

